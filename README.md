1 SIMULADOR DE PIPELINE
    O simulador de pipeline será a implementação de uma ferramenta que simula a execução em pipeline 5 estágios do MIPS. O simulador receberá como entrada um conjunto de instruções em Assembly MIPS, simula a execução dessas instruções considerando todas as dependências de dados e conflitos estruturais e, tem como saída, a quantidade de ciclos necessários para executar essas instruções e a informação sobre os estágios em cada ciclo.
1.1 DESCRIÇÃO
    Neste contexto, o projeto recebeu algumas restrições na forma de execução e saída, onde foi considerado um pipeline de 5 estágios na arquitetura Harvard onde os estágios são: IF, ID, EX, MEM, WB. Também para esse projeto foi restrito apenas as instruções ADD, SUB, BEQ, BNE, LW, SW e JUMP. Também não podendo haver reordenação e redirecionamento das instruções para otimização de ciclos. Assim o programa terá que no caso de conflito de dados, que a ferramenta seja capaz de detectar as dependências de dados e parar o pipeline até que a dependência e no caso de conflito de controle, onde haja funções que irá ter labels, sempre será tomado o salto.
1.2 FUNCIONAMENTO
    Para essa implementação, foi utilizado a linguagem C++ com a utilização de duas bibliotecas não padrão da linguagem, sendo elas: a string, onde as strings declaradas se comportam como objetos que representam sequências de caracteres; e a vector, onde os vector quando declarados se comportam como vetores de quaisquer tipos de dados, onde internamente são alocadas dinamicamente para armazenar os seus elementos.
    O programa se baseia na seguinte lógica, será alocado em um vector de strings todas as linhas de código, logo após, será inicializado um vector de strings com “0” para cada estágio de execução em seu pior caso, ou seja, havendo dependência em todas as linhas de código. Posteriormente, será lido cada cada instrução, onde será testado as dependências de registradores com a linha de código executada anteriormente e colocado o atraso no primeiro ciclo de execução da linha lida, na perspectiva de bolhas se for preciso, caso contrário, já será posto sua inicialização. Em ambas perspectivas ditas anteriormente, será lido o ciclo atual de execução e posto no vector de cada estágio a linha de código lida, fazendo com que a mesma passe por todos os estágios, ciclo após ciclo, até sua conclusão. Também quando for posta funções que terão que pular para um label, será procurado o label nas instruções abaixo e logo após será alocado novamente em cada ciclo correspondente, respeitando as dependências. Depois de alocadas todas as instruções, será mostrado na tela a quantidade de ciclos para execução do programa no paradigma posto na descrição e será mostrado sua execução por ciclo, assim terminando a execução do programa.
Para execução do programa, terá que ser posto na pasta strings do programa um arquivo de entrada qualquer, como por exemplo, entrada.in, assim será preciso via terminal do linux receber o arquivo de entrada (em formato .in) com as instruções e criar um arquivo com resultado final da implementação do programa, como por exemplo, saida.out, onde a linha escrita no terminal deverá ser assim:
usuario@usuario-pc:~/lab01/strings$ bin/lab01 < entrada.in > saida.out

